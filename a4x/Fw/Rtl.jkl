//
// Contains the Rtl routines.
// TEMP: To be split up and moved out of the firmware codebase.
//

#INCLUDE "<inc>/Rtl.hjk"

#ASM [

;a0 - ptr
;a1 - size
;a2 - ulong
RtlFillMemoryWithUlong:
.global RtlFillMemoryWithUlong
    beq  a1, .b1done

.gzero:
    xori t1, a0, 3
    addi t1, t1, 1
    andi t1, t1, 3

    beq  t1, .fdone

    mov  t2, a2

    slt  t3, t1, a1
    bne  t3, .goodlen

    mov  t1, a1

.goodlen:
    sub  a1, a1, t1

.fu:
    mov  byte [a0], t2

    rshi t2, t2, 8

    addi a0, a0, 1
    subi t1, t1, 1
    bne  t1, .fu

.fdone:
    ;ptr is now aligned

    rshi t1, a1, 6 ;do 64 bytes each loop

    beq  t1, .b64done

.b64:
    mov  long [a0], a2
    mov  long [a0 + 4], a2
    mov  long [a0 + 8], a2
    mov  long [a0 + 12], a2
    mov  long [a0 + 16], a2
    mov  long [a0 + 20], a2
    mov  long [a0 + 24], a2
    mov  long [a0 + 28], a2
    mov  long [a0 + 32], a2
    mov  long [a0 + 36], a2
    mov  long [a0 + 40], a2
    mov  long [a0 + 44], a2
    mov  long [a0 + 48], a2
    mov  long [a0 + 52], a2
    mov  long [a0 + 56], a2
    mov  long [a0 + 60], a2

    addi a0, a0, 64
    subi t1, t1, 1
    bne  t1, .b64

.b64done:
    andi t1, a1, 63

    rshi t1, t1, 2 ;do 4 bytes each loop

    beq  t1, .b4done

.b4:
    mov  long [a0], a2

    addi a0, a0, 4
    subi t1, t1, 1
    bne  t1, .b4

.b4done:
    andi t1, a1, 3 ;do 1 byte each loop

    beq  t1, .b1done

.b1:
    mov  byte [a0], a2

    rshi a2, a2, 8

    addi a0, a0, 1
    subi t1, t1, 1
    bne  t1, .b1

.b1done:
    ret

;a0 - dest
;a1 - src
;a2 - sz
RtlCopyBytes:
.global RtlCopyBytes
    beq  a2, .zerosize

    xor  t0, a1, a0

    andi t1, t0, 1
    bne  t1, .unaligned

.aligned_with_eachother:
    xori t1, a1, 3
    addi t1, t1, 1
    andi t1, t1, 3

    beq  t1, .fdone

    slt  t3, t1, a2
    bne  t3, .goodlen

    mov  t1, a2

.goodlen:
    sub  a2, a2, t1

.fu:
    mov  t2, byte [a1]
    mov  byte [a0], t2

    addi a1, a1, 1
    addi a0, a0, 1
    subi t1, t1, 1
    bne  t1, .fu

.fdone:
    andi t1, t0, 3
    beq  t1, .aligned32

.aligned16:
    rshi t0, a2, 6 ;do 64 bytes each loop

    beq  t0, .copy16_by_64done

.copy16_by_64:
    mov  t1, int [a1]
    mov  t2, int [a1 + 2]
    mov  t3, int [a1 + 4]
    mov  t4, int [a1 + 6]

    mov  int [a0], t1
    mov  int [a0 + 2], t2
    mov  int [a0 + 4], t3
    mov  int [a0 + 6], t4

    mov  t1, int [a1 + 8]
    mov  t2, int [a1 + 10]
    mov  t3, int [a1 + 12]
    mov  t4, int [a1 + 14]

    mov  int [a0 + 8], t1
    mov  int [a0 + 10], t2
    mov  int [a0 + 12], t3
    mov  int [a0 + 14], t4

    mov  t1, int [a1 + 16]
    mov  t2, int [a1 + 18]
    mov  t3, int [a1 + 20]
    mov  t4, int [a1 + 22]

    mov  int [a0 + 16], t1
    mov  int [a0 + 18], t2
    mov  int [a0 + 20], t3
    mov  int [a0 + 22], t4

    mov  t1, int [a1 + 24]
    mov  t2, int [a1 + 26]
    mov  t3, int [a1 + 28]
    mov  t4, int [a1 + 30]

    mov  int [a0 + 24], t1
    mov  int [a0 + 26], t2
    mov  int [a0 + 28], t3
    mov  int [a0 + 30], t4

    mov  t1, int [a1 + 32]
    mov  t2, int [a1 + 34]
    mov  t3, int [a1 + 36]
    mov  t4, int [a1 + 38]

    mov  int [a0 + 32], t1
    mov  int [a0 + 34], t2
    mov  int [a0 + 36], t3
    mov  int [a0 + 38], t4

    mov  t1, int [a1 + 40]
    mov  t2, int [a1 + 42]
    mov  t3, int [a1 + 44]
    mov  t4, int [a1 + 46]

    mov  int [a0 + 40], t1
    mov  int [a0 + 42], t2
    mov  int [a0 + 44], t3
    mov  int [a0 + 46], t4

    mov  t1, int [a1 + 48]
    mov  t2, int [a1 + 50]
    mov  t3, int [a1 + 52]
    mov  t4, int [a1 + 54]

    mov  int [a0 + 48], t1
    mov  int [a0 + 50], t2
    mov  int [a0 + 52], t3
    mov  int [a0 + 54], t4

    mov  t1, int [a1 + 56]
    mov  t2, int [a1 + 58]
    mov  t3, int [a1 + 60]
    mov  t4, int [a1 + 62]

    mov  int [a0 + 56], t1
    mov  int [a0 + 58], t2
    mov  int [a0 + 60], t3
    mov  int [a0 + 62], t4

    addi a0, a0, 64
    addi a1, a1, 64
    subi t0, t0, 1
    bne  t0, .copy16_by_64

.copy16_by_64done:
    andi t0, a2, 63

    b    .copy_last_bytes

.aligned32:
    rshi t0, a2, 6 ;do 64 bytes each loop

    beq  t0, .copy32_by_64done

.copy32_by_64:
    mov  t1, long [a1]
    mov  t2, long [a1 + 4]
    mov  t3, long [a1 + 8]
    mov  t4, long [a1 + 12]

    mov  long [a0], t1
    mov  long [a0 + 4], t2
    mov  long [a0 + 8], t3
    mov  long [a0 + 12], t4

    mov  t1, long [a1 + 16]
    mov  t2, long [a1 + 20]
    mov  t3, long [a1 + 24]
    mov  t4, long [a1 + 28]

    mov  long [a0 + 16], t1
    mov  long [a0 + 20], t2
    mov  long [a0 + 24], t3
    mov  long [a0 + 28], t4

    mov  t1, long [a1 + 32]
    mov  t2, long [a1 + 36]
    mov  t3, long [a1 + 40]
    mov  t4, long [a1 + 44]

    mov  long [a0 + 32], t1
    mov  long [a0 + 36], t2
    mov  long [a0 + 40], t3
    mov  long [a0 + 44], t4

    mov  t1, long [a1 + 48]
    mov  t2, long [a1 + 52]
    mov  t3, long [a1 + 56]
    mov  t4, long [a1 + 60]

    mov  long [a0 + 48], t1
    mov  long [a0 + 52], t2
    mov  long [a0 + 56], t3
    mov  long [a0 + 60], t4

    addi a0, a0, 64
    addi a1, a1, 64
    subi t0, t0, 1
    bne  t0, .copy32_by_64

.copy32_by_64done:
    andi t0, a2, 63

    b    .copy_last_bytes

.unaligned:
    rshi t0, a2, 5 ;do 32 bytes each loop

    beq  t0, .copy8_by_32done

.copy8_by_32:
    mov  t1, byte [a1]
    mov  t2, byte [a1 + 1]
    mov  t3, byte [a1 + 2]
    mov  t4, byte [a1 + 3]

    mov  byte [a0], t1
    mov  byte [a0 + 1], t2
    mov  byte [a0 + 2], t3
    mov  byte [a0 + 3], t4

    mov  t1, byte [a1 + 4]
    mov  t2, byte [a1 + 5]
    mov  t3, byte [a1 + 6]
    mov  t4, byte [a1 + 7]

    mov  byte [a0 + 4], t1
    mov  byte [a0 + 5], t2
    mov  byte [a0 + 6], t3
    mov  byte [a0 + 7], t4

    mov  t1, byte [a1 + 8]
    mov  t2, byte [a1 + 9]
    mov  t3, byte [a1 + 10]
    mov  t4, byte [a1 + 11]

    mov  byte [a0 + 8], t1
    mov  byte [a0 + 9], t2
    mov  byte [a0 + 10], t3
    mov  byte [a0 + 11], t4

    mov  t1, byte [a1 + 12]
    mov  t2, byte [a1 + 13]
    mov  t3, byte [a1 + 14]
    mov  t4, byte [a1 + 15]

    mov  byte [a0 + 12], t1
    mov  byte [a0 + 13], t2
    mov  byte [a0 + 14], t3
    mov  byte [a0 + 15], t4

    mov  t1, byte [a1 + 16]
    mov  t2, byte [a1 + 17]
    mov  t3, byte [a1 + 18]
    mov  t4, byte [a1 + 19]

    mov  byte [a0 + 16], t1
    mov  byte [a0 + 17], t2
    mov  byte [a0 + 18], t3
    mov  byte [a0 + 19], t4

    mov  t1, byte [a1 + 20]
    mov  t2, byte [a1 + 21]
    mov  t3, byte [a1 + 22]
    mov  t4, byte [a1 + 23]

    mov  byte [a0 + 20], t1
    mov  byte [a0 + 21], t2
    mov  byte [a0 + 22], t3
    mov  byte [a0 + 23], t4

    mov  t1, byte [a1 + 24]
    mov  t2, byte [a1 + 25]
    mov  t3, byte [a1 + 26]
    mov  t4, byte [a1 + 27]

    mov  byte [a0 + 24], t1
    mov  byte [a0 + 25], t2
    mov  byte [a0 + 26], t3
    mov  byte [a0 + 27], t4

    mov  t1, byte [a1 + 28]
    mov  t2, byte [a1 + 29]
    mov  t3, byte [a1 + 30]
    mov  t4, byte [a1 + 31]

    mov  byte [a0 + 28], t1
    mov  byte [a0 + 29], t2
    mov  byte [a0 + 30], t3
    mov  byte [a0 + 31], t4

    addi a0, a0, 32
    addi a1, a1, 32
    subi t0, t0, 1
    bne  t0, .copy8_by_32

.copy8_by_32done:
    andi t0, a2, 31 ;do 1 byte each loop

.copy_last_bytes:
    beq  t0, .done

.b1:
    mov  t1, byte [a1]
    mov  byte [a0], t1

    addi a0, a0, 1
    addi a1, a1, 1
    subi t0, t0, 1
    bne  t0, .b1

.zerosize:
.done:
    ret

]

EXTERN FN FwCioPutCharacter (
    IN byte : UWORD,
)

FN (RtlPrintCallbackF) RtlpPrintCallback (
    IN byte : UBYTE,
    IN context : ^VOID,
)

    // TEMP
    FwCioPutCharacter ( byte )
END

FNPTR RtlpFormatF (
    IN callback : RtlPrintCallbackF,
    IN context : ^VOID,
    IN flag : UWORD,
    IN arg : UWORD,
    IN value : ^VOID,
)

#DEFINE RTL_PRINT_ARG_NEG  1
#DEFINE RTL_PRINT_ARG_ZERO 2
#DEFINE RTL_PRINT_ARG      4

#MACRO RtlpPad ( char, callback, context, count ) [
    i := count

    WHILE i DO
        callback ( char, context )

        i -= 1
    END
]

FN (RtlpFormatF) RtlpFormatS (
    IN callback : RtlPrintCallbackF,
    IN context : ^VOID,
    IN flag : UWORD,
    IN arg : UWORD,
    IN value : ^VOID,
)

    len : UWORD

    IF flag & RTL_PRINT_ARG THEN
        len = RtlMeasureString ( value )

        IF NOT (flag & RTL_PRINT_ARG_NEG) AND arg > len THEN
            // Align to the right.

            RtlpPad ( ' ', callback, context, arg - len )
        END
    END

    WHILE (CAST value TO ^UBYTE)^ DO
        callback ( (CAST value TO ^UBYTE)^, context )

        value += 1
    END

    IF flag & RTL_PRINT_ARG_NEG AND arg > len THEN
        // Align to the left.

        RtlpPad ( ' ', callback, context, arg - len )
    END
END

FN RtlpFormatInteger (
    IN callback : RtlPrintCallbackF,
    IN context : ^VOID,
    IN flag : UWORD,
    IN arg : UWORD,
    IN number : UWORD,
    IN signed : UWORD,
    IN base : UBYTE,
)

    log10 := 0
    divisor := 1
    signedbias := 0

    padchar := ' '

    IF flag & RTL_PRINT_ARG_ZERO THEN
        padchar = '0'
    END

    IF signed AND number & 0x80000000 THEN
        number = -number

        signedbias = 1
    END

    IF number == 0 THEN
        log10 = 1

    ELSE
        n := number

        WHILE n >= base DO
            divisor *= base
            n /= base
            log10 += 1
        END

        log10 += 1
    END

    IF flag & RTL_PRINT_ARG THEN
        IF NOT (flag & RTL_PRINT_ARG_NEG) AND arg > log10 + signedbias THEN
            // Align to the right.

            RtlpPad ( padchar, callback, context, arg - (log10 + signedbias) )
        END
    END

    IF signedbias THEN
        callback ( '-', context )
    END

    WHILE log10 DO
        digit := (number / divisor) % base

        IF digit > 9 THEN
            digit = digit - 10 + 'A'

        ELSE
            digit += '0'
        END

        callback ( digit, context )

        log10 -= 1
        divisor /= base
    END

    IF flag & RTL_PRINT_ARG_NEG AND arg > log10 + signedbias THEN
        // Align to the left.

        RtlpPad ( ' ', callback, context, arg - (log10 + signedbias) )
    END
END

FN (RtlpFormatF) RtlpFormatD (
    IN callback : RtlPrintCallbackF,
    IN context : ^VOID,
    IN flag : UWORD,
    IN arg : UWORD,
    IN value : ^VOID,
)

    RtlpFormatInteger (
        callback, // callback
        context, // context
        flag, // flag
        arg, // arg
        CAST value TO UWORD, // number
        TRUE, // signed
        10, // base
    )
END

FN (RtlpFormatF) RtlpFormatU (
    IN callback : RtlPrintCallbackF,
    IN context : ^VOID,
    IN flag : UWORD,
    IN arg : UWORD,
    IN value : ^VOID,
)

    RtlpFormatInteger (
        callback, // callback
        context, // context
        flag, // flag
        arg, // arg
        CAST value TO UWORD, // number
        FALSE, // signed
        10, // base
    )
END

FN (RtlpFormatF) RtlpFormatX (
    IN callback : RtlPrintCallbackF,
    IN context : ^VOID,
    IN flag : UWORD,
    IN arg : UWORD,
    IN value : ^VOID,
)

    RtlpFormatInteger (
        callback, // callback
        context, // context
        flag, // flag
        arg, // arg
        CAST value TO UWORD, // number
        FALSE, // signed
        16, // base
    )
END

FN (RtlpFormatF) RtlpFormatP (
    IN callback : RtlPrintCallbackF,
    IN context : ^VOID,
    IN flag : UWORD,
    IN arg : UWORD,
    IN value : ^VOID,
)

    IF flag == 0 THEN
        arg = 8
    END

    RtlpFormatInteger (
        callback, // callback
        context, // context
        RTL_PRINT_ARG_ZERO | RTL_PRINT_ARG, // flag
        arg, // arg
        CAST value TO UWORD, // number
        FALSE, // signed
        16, // base
    )
END

FN (RtlpFormatF) RtlpFormatC (
    IN callback : RtlPrintCallbackF,
    IN context : ^VOID,
    IN flag : UWORD,
    IN arg : UWORD,
    IN value : ^VOID,
)

    IF flag & RTL_PRINT_ARG THEN
        IF NOT (flag & RTL_PRINT_ARG_NEG) AND arg > 1 THEN
            // Align to the right.

            RtlpPad ( ' ', callback, context, arg - 1 )
        END
    END

    callback ( CAST value TO UBYTE, context )

    IF flag & RTL_PRINT_ARG_NEG AND arg > 1 THEN
        // Align to the left.

        RtlpPad ( ' ', callback, context, arg - 1 )
    END
END

#SECTION "text"
RtlpFormatters : RtlpFormatF['z' - 'a' + 1] = {
    ['s' - 'a'] = &RtlpFormatS,
    ['d' - 'a'] = &RtlpFormatD,
    ['u' - 'a'] = &RtlpFormatU,
    ['x' - 'a'] = &RtlpFormatX,
    ['p' - 'a'] = &RtlpFormatP,
    ['c' - 'a'] = &RtlpFormatC,
}

FN RtlPrintByCallbackByVarTable (
    IN callback : RtlPrintCallbackF,
    IN context : ^VOID,
    IN fmt : ^UBYTE,
    IN argv : ^^VOID,
    IN argc : UWORD,
)

    // This is the one that actually does stuff!

    i := 0

    WHILE fmt^ DO
        byte := fmt^

        IF byte != '%' THEN
            callback ( byte, context )

        ELSE
            fmt += 1

            byte = fmt^

            IF NOT byte THEN
                callback ( '?', context )

                LEAVE
            END

            IF byte == '%' THEN
                callback ( '%', context )

                fmt += 1

                CONTINUE
            END

            arg := 0
            flag := 0

            IF byte == '-' THEN
                flag |= RTL_PRINT_ARG_NEG

                fmt += 1
                byte = fmt^
            END

            IF byte == '0' THEN
                flag |= RTL_PRINT_ARG_ZERO

                fmt += 1
                byte = fmt^
            END

            WHILE byte >= '0' AND byte <= '9' DO
                flag |= RTL_PRINT_ARG

                arg *= 10
                arg += byte - '0'

                fmt += 1
                byte = fmt^
            END

            IF byte >= 'a' AND
                byte <= 'z' AND
                i < argc AND
                RtlpFormatters[byte - 'a'] THEN

                RtlpFormatters[byte - 'a'] (
                    callback, // callback
                    context, // context
                    flag, // flag
                    arg, // arg
                    argv[i], // value
                )

                i += 1

            ELSE
                callback ( '?', context )
            END
        END

        fmt += 1
    END
END

FN RtlPrintByCallback (
    IN callback : RtlPrintCallbackF,
    IN context : ^VOID,
    IN fmt : ^UBYTE,
    ... argv argc
)

    RtlPrintByCallbackByVarTable (
        callback, // callback
        context, // context
        fmt, // fmt
        argv, // argv
        argc, // argc
    )
END

FN RtlPrintByVarTable (
    IN handle : ^VOID,
    IN fmt : ^UBYTE,
    IN argv : ^^VOID,
    IN argc : UWORD,
)

    RtlPrintByCallbackByVarTable (
        &RtlpPrintCallback, // callback
        handle, // context
        fmt, // fmt
        argv, // argv
        argc, // argc
    )
END

FN RtlPrintByHandle (
    IN handle : ^VOID,
    IN fmt : ^UBYTE,
    ... argv argc
)

    RtlPrintByVarTable (
        handle, // handle
        fmt, // fmt
        argv, // argv
        argc, // argc
    )
END

FN RtlPrint (
    IN fmt : ^UBYTE,
    ... argv argc
)

    RtlPrintByVarTable (
        NULLPTR, // handle
        fmt, // fmt
        argv, // argv
        argc, // argc
    )
END

STRUCT RtlpFormatContext
    BufferLeft : UWORD,
    Buffer : ^UBYTE,
END

FN (RtlPrintCallbackF) RtlFormatCallback (
    IN byte : UBYTE,
    IN context : ^VOID,
)

    formatcontext := CAST context TO ^RtlpFormatContext

    IF NOT formatcontext^.BufferLeft THEN
        LEAVE
    END

    formatcontext^.Buffer^ = byte
    formatcontext^.Buffer += 1
    formatcontext^.BufferLeft -= 1
END

FN RtlFormatByVarTable (
    IN dest : ^UBYTE,
    IN bufsize : UWORD,
    IN fmt : ^UBYTE,
    IN argv : ^^VOID,
    IN argc : UWORD,
)

    // Format into the provided buffer.

    IF NOT bufsize THEN
        LEAVE
    END

    context : RtlpFormatContext

    context.Buffer = dest
    context.BufferLeft = bufsize - 1

    RtlPrintByCallbackByVarTable (
        &RtlFormatCallback, // callback
        &context, // context
        fmt, // fmt
        argv, // argv
        argc, // argc
    )

    // Insert null terminator.

    context.Buffer^ = 0
END

FN RtlFormat (
    IN dest : ^UBYTE,
    IN bufsize : UWORD,
    IN fmt : ^UBYTE,
    ... argv argc
)

    RtlFormatByVarTable (
        dest, // dest
        bufsize, // bufsize
        fmt, // fmt
        argv, // argv
        argc, // argc
    )
END

FN RtlCompareString (
    IN str1 : ^UBYTE,
    IN str2 : ^UBYTE,
) : UWORD

    i := 0

    WHILE TRUE DO
        IF NOT str1[i] AND NOT str2[i] THEN
            RETURN 0
        END

        IF str1[i] != str2[i] THEN
            RETURN str1[i] - str2[i]
        END

        i += 1
    END
END

FN RtlCompareStringWithMax (
    IN str1 : ^UBYTE,
    IN str2 : ^UBYTE,
    IN count : UWORD,
) : UWORD

    i := 0

    WHILE i < count DO
        IF NOT str1[i] AND NOT str2[i] THEN
            RETURN 0
        END

        IF str1[i] != str2[i] THEN
            RETURN str1[i] - str2[i]
        END

        i += 1
    END

    RETURN 0
END

FN RtlMeasureString (
    IN str : ^UBYTE,
) : UWORD

    cnt := 0

    WHILE str[cnt] DO
        cnt += 1
    END

    RETURN cnt
END

FN RtlCopyString (
    IN dest : ^UBYTE,
    IN src : ^UBYTE,
    IN bufsize : UWORD,
)

    IF NOT bufsize THEN
        LEAVE
    END

    WHILE bufsize - 1 DO
        dest^ = src^

        dest += 1
        src += 1
        bufsize -= 1

        IF src^ == 0 THEN
            BREAK
        END
    END

    dest^ = 0
END

FN RtlStringToNumber (
    IN src : ^UBYTE,
    IN bufsize : UWORD,
    OUT num : UWORD,
) : UWORD

    IF bufsize < 1 THEN
        RETURN FALSE
    END

    IF src^ == 0 THEN
        RETURN FALSE
    END

    base := 10

    IF src^ == '0' THEN
        // Octal or hex.

        base = 8
        bufsize -= 1
        src += 1

        IF bufsize < 1 THEN
            num = 0

            RETURN TRUE
        END

        IF src^ == 'x' THEN
            // Hex.

            base = 16

            bufsize -= 1
            src += 1

            IF bufsize < 1 OR src^ == 0 THEN
                RETURN FALSE
            END
        END
    END

    num = 0

    WHILE bufsize DO
        byte := src^

        IF byte == 0 THEN
            RETURN TRUE
        END

        num *= base

        IF base == 16 THEN
            IF byte >= '0' AND byte <= '9' THEN
                num += src^ - '0'
            
            ELSEIF byte >= 'A' AND byte <= 'F' THEN
                num += src^ - 'A'

            ELSE
                RETURN FALSE
            END

        ELSEIF byte >= '0' AND byte <= '9' THEN
            num += src^ - '0'
        
        ELSE
            RETURN FALSE
        END

        src += 1
        bufsize -= 1
    END

    RETURN TRUE
END

FN RtlTokenize (
    IN buffer : ^UBYTE,
    IN tokenbuffer : ^UBYTE,
    IN bufsize : UWORD,
    IN delimiter : UBYTE,
) : ^UBYTE

    // Return the next token from the buffer.

    WHILE buffer^ == delimiter DO
        buffer += 1
    END

    IF NOT buffer^ THEN
        RETURN NULLPTR
    END

    WHILE bufsize - 1 DO
        IF buffer^ == delimiter OR NOT buffer^ THEN
            BREAK
        END

        tokenbuffer^ = buffer^

        tokenbuffer += 1
        buffer += 1
        bufsize -= 1
    END

    tokenbuffer^ = 0

    RETURN buffer
END